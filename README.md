#  The Black Market a Game by Nicholas Flynn
#### Video Demo:  <https://youtu.be/KyLUu47NS_M>
#### Description: 
**The current limit for the days var in the HomeView is set to 31 but please feel free to change to 5 for testing for those at CS50x or who may test this app. The game should be played at 31 days. But you can adjust for a better/quicker experience. if usrData.days >= 31 change the 31 to 5 in Home. Otherwise the app could take some time to test** It took some time for me to figure out how to map out this game. Instead of trying to think of everything I needed right away then build piece by piece I just started to work on it. Little by little I was able to accomplish very important parts of the game in order to move to the next part. Each section of the game I built took a lot of time and a lot of learning for me to finish. I chose to build my project in Xcode as I wanted to not only use Swift but to challenge myself to learn both Xcode and the Swift programming language. This at first was almost way too much for me and I feel if I would have stuck to C or Python I probably would not have gotten hung up as often. Sometime's Xcode halted progress and sometime's it was Swift but all due to a learning curve or experience for me. Making this app has not only forced me to learn a lot about programing in general but Swift, Xcode and how to research issues and build my own solutions. There are many ways to do the same thing and sometime's it's just about picking one and running with it when it suits you. 
### Game's desc:
My game "The Black Market" is a game set in a Cyberpunk future where you, the user takes on the persona of a futuristic dealer of black market goods. You must travel to different store's IP Addresses as this is all done via an online terminal which is something reminiscent of older computers. The game's design overall is simple and it's gameplay maybe even simpler but the challenge in this first rendition is to buy and sell with different IP address stores to earn the most money you can before the game ends and you can choose to try again for a higher score. The money is your score so it is best to try for the highest score you can get. Will you choose to buy and sell many cheaper items or work your way up to the more expensive ones? You have 31 days to make your cash before the game comes to a stop. 
### Design:
First lets take a look at the design. I purposely did not want to spend too much time on design as it is my first game/app I am making on my own. I wanted to keep it simple and get into the hard part which is the coding. I did not use many drag and drop design elements like I thought I would going into it. I instead found it was easier to just color my text, navigationLinks and other elements to make them directly apart of the design instead of being hidden behind a button. So the app is really a lot of text the user will be clicking on and interacting with. All the text is green and the backgrounds are all blacked out. I was going for a 1990s, Matrix old 80s computer Esq. style with this one. I believe I nailed it as I even using knowledge of color codes and how to use them in programing from CS50x used the same color code as the Matrix movies for the green. I kept the design simple using this idea and so they user will enter their alias in a green text box which is a secure text field in order to make things feel especially "hacker" click to enter and be greeted with their Alias, amount of money (5k) and a list of stores they can visit. Once they click a store it will show all the items available at the IPstore and at the bottom allow them to buy or sell. only these buttons change colors as the buy button is red. There is a box for the user to enter the amount they want to buy or sell and then they can do so in the store to their hearts content as long as their wallet is big enough. 
## Under the Hood
### Views
In order for this game to work I had to design several features which I found to be very difficult to start. First were the different Views in Swift. This app has 4 main Swift Views the user will interact with. The starting page "ContentView", the "Home" page where the user has a list of stores, the "MarketPage" where the user can buy and sell their items and lastly the "GameOver" view where the user will finish their session and have the option to play again. These aren't the only files needed to run the game as each SwiftView is using instances often created in another Swift File or view. This was a learning experience for as I have never properly made an app with multiple views or pages in it. This app has 10 different Swift files with the SwiftViews being apart of that ten. The market page is really the biggest page of them all as it has the most interaction and links to all the other pages or views in the app. In order for the market page to work right it has to properly use instances from Market which also requires data from Item where the code for the Items are stored. That code has the instances for each item. Not all stores have the same items however and that is decided within the Market view. This is all then passed to the Market Page which of course still needs access to the user's data from UsrData in order to see how much money they have outside of just displaying it. To explain the other views is pretty simple so I explained the more complicated MarketPage first. The others are more or less just displaying information from USrData like the username and money. They also usually have links like the store's or the play again button in GameOver which takes you back to Content view in order to put your Alias in and it reset's your money to the starting amount of 5k. This view also will not let you go forward unless you do type something. Your username could be anything but you MUST type something in the box to move forward or the text box will ask "Who are you?" Upon typing at least one character into the text box the user will be be allowed to click the text below the enter the black market which also quickly explains the metric's of the game. I think this game nicely uses it's data and views to subtly wrap you around to the end and back into it.
### Mechanics at play
The game itself is simple enough but the mechanics behind it can get a little complicated. In general this game is running in several views using many different instances of items and stores in order to create an environment for the user to operate in but that would mean nothing without the user being able to interact with it all which is where the user's inventory comes in. This is where things become a little abstract as it is an array of the item's instance's however I could not get the array to work properly without creating two different arrays. One array would be used by the markets and the other by the user. The names underthehood were altered even though the text the user sees doesn't seem different. I also had to add an ID number to each item instance and basically give the user each item with the amount set to zero. Something I feel proud to have come up with was a way to query those items by their ID as they need to match but if they did match the app wouldn't let the user buy and sell properly. The ID numbers are offset by multiples of ten. The only way for the market to make the correct match when a user wants to buy a certain item would be for a calculation to take place multiplying the item selected's ID number by 10 and matching that ID number for the user. This way the market's amount only goes down when the user buys from it. This way the correct calculations are taking place adding the right amount of said item to the user's inventory where that item exists and subtracting from the market item's amount by the amount they entered. This i think is one of the more powerful features in this app. The game lives and dies on this very feature as if it did not work right the game did not work at all so a lot of time and dedication was put into making sure this runs properly ensuring transactions can be made. It is the part I am most proud of inside my app as it is something that took me the longest and something I was able to find my own unique solution to solve the issue of one array for all item instances between the market and user. As for the other mechanics the game has an Inv class with an array of all the item instances. Each item instance has a unique ID and name then a function is run each time the Home page appears that will randomize the amounts and prices of the items within a range per item. Some items are more expensive some are cheaper. Some more rare with only select stores carrying smaller amounts with high prices. The stores themselves decide what items they carry. A lot of the game's functions actually take place not when loading the store but instead when loading the Home page where the user can select the store. Everything takes place .OnAppear at that point everything changes including the day counter. The days change when you travel back to Home instead of going to each store. I felt that was simpler. As the days count up to 31 it triggers a bool statement which shows the GameOver view until that is false. It becomes false or less than 31 when the user clicks play again. This sets the days back to 0 and the user's money back to 5000. They then re enter their name or a new name into the secure text field and start again.
### Issues during the build process 
From the start I restarted production about 3 times. This was supposed to be a Python based app in Xcode as I wanted to set that up and learn it on my computer. I was looking to challenge myself...it was too great and eventually I landed on Swift in Xcode of Python in VSCode. I chose to learn Xcode. This was a bigger learning curve than I thought and at the start of my work on The Black Market the preview broke and I was never able to fix it so for testing I had to execute the program and launch it on the simulator, start at the beginning and navigate through the entire app in order to test simple things or see my views. This was a major annoyance but I couldn't find a way to fix it. I also did not understand a lot about Swift so even SwiftViews were foreign to me till I started thinking of them as separate webpages. Then it made a lot more sense. I still however struggle with sharing data between views, arrays and different types of instances. I can make them but using them is another thing I struggle with. For instance I created the Items array but going through it to match the selected item the user clicked on with what I wanted the array to find was really challenging. Properly using an array is something that I thought I kind of understood but in practice it took me a few weeks to figure it out eventually landing on a solution to create multiple instances of the same item within the array then query it by the ID numbers. This was the most simple way to solve my issue without rewriting a ton of code I had already designed. Small tweaks and it worked. Other issues I had at the beginning were with design. ZStacks, Hstacks and VStacks can be colored but not the way I thought they were being colored which left big while squares all over my app. It took a little while but I was able to find a solution with ZStacks. If i put it all in a ZStack then colored that the background of my app would stay all black the way it was supposed to be. I also experienced issues finding solutions as sometimes the solution itself was so above my level I couldn't understand it which was a reoccurring problem throughout my processes. Sometimes the advice or websites I would find with examples were either way above my head or way too simple for me to apply it to the more complicated issues within my code resulting in what felt like loops of issues. 
### Proper use of the DuckDebugger and AI tools to help code
I knew going into this I was going to need some level of assistance and seeing I was aloud to do so within the rules of the final project I took advantage of the tools available to me. I made sure to stay within the rules of the class and never just asked for answers and copied it as that wont help me and isn't an honest thing to do. I was strict on myself when using these tools to only use them in ways that made me learn then if it was too complicated or over my head/level i would not take the advice. CS50x thought me a few very valuable things and one of them is know how to ask the right questions. So I liked using the AI tools like dictionaries or a teacher who doesn't just give the answers away. This way i could quickly gain access to informations and work through ideas like a sketchpad that writes back to me. This helped me a lot as i could figure out how one could write some things in Swift then bend that and try it in my own way. I also used AI to help debug certain errors as i did not know what they meant most of the time or how to fix them. New to programing and very new to Swift(kind of. I started with Swift years ago but moved to other languages) I found it was much better to work through my ideas with the duckdebugger than trying to google it as the google results and Swift documentation were to abstract for my issues or I couldn't find anything helpful. When working with the duckdeugger I got advice rather than just answers so even with that I was able to learn more, look up more and find my answers to issues I was having. I felt better equipped and felt the duckdebugger was a lot more helpful in my journey to learn about programing and get help as if it was a live teacher. The thing I did not like it is it would forget the whole conversation if i didn't keep asking it questions within a certain time on the web version. ChatGPT was also used as a way to debug through my code and i made sure to start the conversation by explicitly stating i did not want just answers but instead was trying to learn the code and how to use it. This prompted the AI to give me helpful answers with examples but I still did not prefer it to the duckdebuger for this assignment. Both AI I felt did end up causing a lot of issues where I might not have walked into those issues if I wasn't asking it for help. The main issues with them were they would sometimes assume something about my code that wasn't true thus programing issues right into the app assuming something was true that wasn't. I would sometimes take advice and implement it but then a whole list of errors would appear and it would cause me to be debugging or trying to figure out what happened for two days before learning I had to change one simple thing like @State vs @bind or @enviormentalObject vs others. It was helpful but in the end it doesn't know my whole code so both programs would often cause 10 problems and solve 3 at a time. I preferred to just search through documentation by the end of the project and to ask the AI if what i was trying to do was correct/or the right idea. That way it was much more helpful. 
